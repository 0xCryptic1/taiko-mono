/**
 * Verifies that the value of a slot in the storage tree of `addr`
 * is `value`.
 *
 * @param stateRoot The merkle root of state tree.
 * @param addr The contract address.
 * @param slot The slot in the contract.
 * @param value The value to be verified.
 * @param mkproof The proof obtained by encoding state proof and storage
 *        proof.
 * @return verified The verification result.
 */
function verify(
    bytes32 stateRoot,
    address addr,
    bytes32 slot,
    bytes32 value,
    bytes calldata mkproof
) public pure returns (bool verified) {
    // Decode the `mkproof` parameter into separate `accountProof` and `storageProof` byte arrays.
    (bytes memory accountProof, bytes memory storageProof) = abi.decode(
        mkproof,
        (bytes, bytes)
    );

    // Retrieve the RLP-encoded account state for the specified address using the `get` function from the `LibSecureMerkleTrie` library.
    //Megnézi hogy a 'world' stateRoot-ból ki tudja-e szedni az RLP-encoded account-t.
    (bool exists, bytes memory rlpAccount) = LibSecureMerkleTrie.get(
        abi.encodePacked(addr),
        accountProof,
        stateRoot
    );


    // Example contract accountProof:
    //     {
    //         nonce: 1,
    //         balance: 1000,
    //         codeHash: 0x123456789abcdef,
    //         storageHash: 0x987654321fedcba
    //     }
    // Example of a contracts storageProof:
    // [  "0x",  [    {      "key": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef",      "value": {        "nonce": "0x1",        "balance": "0x0",        "storageHash": "0xc0a49e08e1c8f3b3de04ce4fa4eeb8071594da124f92da6da4fa5b5ce5ddc8cc",        "codeHash": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"      }    }  ],
    // [    {      "key": "0x1234",      "value": "0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890"    }  ]
    // ]

    // Check that the account exists in the state tree.
    require(exists, "LTP:invalid account proof");

    // Parse the RLP-encoded account state to extract the storage root hash.
    LibRLPReader.RLPItem[] memory accountState = LibRLPReader.readList(
        rlpAccount
    );
    bytes32 storageRoot = LibRLPReader.readBytes32(
        accountState[ACCOUNT_FIELD_INDEX_STORAGE_HASH]
    );

    // Verify the inclusion of the specified slot and value in the storage tree using the `verifyInclusionProof` function from the `LibSecureMerkleTrie` library.
    verified = LibSecureMerkleTrie.verifyInclusionProof(
        abi.encodePacked(slot),
        LibRLPWriter.writeBytes32(value),
        storageProof,
        storageRoot
    );
}
