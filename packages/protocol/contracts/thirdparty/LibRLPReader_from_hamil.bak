// SPDX-License-Identifier: Apache-2.0

/*
 * @author Hamdi Allam hamdi.allam97@gmail.com
 * Please reach out with any questions or concerns
 */
pragma solidity ^0.8.18;

library LibRLPReader {
    uint8 constant STRING_SHORT_START = 0x80;
    uint8 constant STRING_LONG_START = 0xb8;
    uint8 constant LIST_SHORT_START = 0xc0;
    uint8 constant LIST_LONG_START = 0xf8;
    uint8 constant WORD_SIZE = 32;    

    enum RLPItemType {
        DATA_ITEM,
        LIST_ITEM
    }

    struct RLPItem {
        uint256 length;
        uint256 ptr;
    }

    struct Iterator {
        RLPItem item; // Item that's being iterated over.
        uint256 nextPtr; // Position of the next item in the list.
    }

    /*
     * @dev Returns the next element in the iteration. Reverts if it has not next element.
     * @param self The iterator.
     * @return The next element in the iteration.
     */
    function next(Iterator memory self) internal pure returns (RLPItem memory) {
        require(hasNext(self));

        uint256 ptr = self.nextPtr;
        uint256 itemLength = _itemLength(ptr);
        self.nextPtr = ptr + itemLength;

        return RLPItem(itemLength, ptr);
    }

    /*
     * @dev Returns true if the iteration has more elements.
     * @param self The iterator.
     * @return true if the iteration has more elements.
     */
    function hasNext(Iterator memory self) internal pure returns (bool) {
        RLPItem memory item = self.item;
        return self.nextPtr < item.ptr + item.length;
    }

    /*
     * @param item RLP encoded bytes
     */
    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {
        uint256 ptr;
        assembly {
            ptr := add(item, 0x20)
        }

        return RLPItem(item.length, ptr);
    }

    /*
     * @dev Create an iterator. Reverts if item is not a list.
     * @param self The RLP item.
     * @return An 'Iterator' over the item.
     */
    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {
        require(isList(self));

        uint256 ptr = self.ptr + _payloadOffset(self.ptr);
        return Iterator(self, ptr);
    }

    /*
     * @param the RLP item.
     */
    function rlpLen(RLPItem memory item) internal pure returns (uint256) {
        return item.length;
    }

    /*
     * @param the RLP item.
     * @return (ptr, length) pair: location of the item's payload in memory.
     */
    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {
        uint256 offset = _payloadOffset(item.ptr);
        uint256 ptr = item.ptr + offset;
        uint256 length = item.length - offset; // data length
        return (ptr, length);
    }

    /*
     * @param the RLP item.
     */
    function payloadLen(RLPItem memory item) internal pure returns (uint256) {
        (, uint256 length) = payloadLocation(item);
        return length;
    }

        /**
     * Reads an RLP string value into a string.
     * @param _in RLP string value.
     * @return Decoded string.
     */
    function readString(
        RLPItem memory _in
    ) internal pure returns (string memory) {
        return string(readBytes(_in));
    }

    /**
     * Reads an RLP string value into a string.
     * @param _in RLP string value.
     * @return Decoded string.
     */
    function readString(
        bytes memory _in
    ) internal pure returns (string memory) {
        return readString(toRlpItem(_in));
    }

    function readList(
        bytes memory _in
    ) internal pure returns (RLPItem[] memory) {
        return readList(toRlpItem(_in));
    }

    /*
     * @param the RLP item containing the encoded list.
     */
    // function readList(RLPItem memory item) internal pure returns (RLPItem[] memory) {
    //     require(isList(item));

    //     uint256 items = numItems(item);
    //     RLPItem[] memory result = new RLPItem[](items);

    //     uint256 ptr = item.ptr + _payloadOffset(item.ptr);
    //     uint256 dataLen;
    //     for (uint256 i = 0; i < items; i++) {
    //         dataLen = _itemLength(ptr);
    //         result[i] = RLPItem(dataLen, ptr);
    //         ptr = ptr + dataLen;
    //     }

    //     return result;
    // }
    function readList(
        RLPItem memory _in
    ) internal pure returns (RLPItem[] memory) {
        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);

        require(itemType == RLPItemType.LIST_ITEM, "Invalid RLP list value.");

        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by
        // writing to the length. Since we can't know the number of RLP items without looping over
        // the entire input, we'd have to loop twice to accurately size this array. It's easier to
        // simply set a reasonable maximum list length and decrease the size before we finish.
        RLPItem[] memory out = new RLPItem[](WORD_SIZE);

        uint256 itemCount;
        uint256 offset = listOffset;
        while (offset < _in.length) {
            require(
                itemCount < WORD_SIZE,
                "Provided RLP list exceeds max list length."
            );

            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(
                RLPItem({length: _in.length - offset, ptr: _in.ptr + offset})
            );

            out[itemCount] = RLPItem({
                length: itemLength + itemOffset,
                ptr: _in.ptr + offset
            });

            itemCount += 1;
            offset += itemOffset + itemLength;
        }

        // Decrease the array size to match the actual item count.
        assembly {
            mstore(out, itemCount)
        }

        return out;
    }

    // @return indicator whether encoded payload is a list. negate this function call for isData.
    function isList(RLPItem memory item) internal pure returns (bool) {
        if (item.length == 0) return false;

        uint8 byte0;
        uint256 ptr = item.ptr;
        assembly {
            byte0 := byte(0, mload(ptr))
        }

        if (byte0 < LIST_SHORT_START) return false;
        return true;
    }

    /*
     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.
     * @return keccak256 hash of RLP encoded bytes.
     */
    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {
        uint256 ptr = item.ptr;
        uint256 length = item.length;
        bytes32 result;
        assembly {
            result := keccak256(ptr, length)
        }
        return result;
    }

    /*
     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.
     * @return keccak256 hash of the item payload.
     */
    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {
        (uint256 ptr, uint256 length) = payloadLocation(item);
        bytes32 result;
        assembly {
            result := keccak256(ptr, length)
        }
        return result;
    }

    /** RLPItem conversions into data types **/
    // @returns raw rlp encoding in bytes
    function readRawBytes(RLPItem memory item) internal pure returns (bytes memory) {
        bytes memory result = new bytes(item.length);
        if (result.length == 0) return result;

        uint256 ptr;
        assembly {
            ptr := add(0x20, result)
        }

        copy(item.ptr, ptr, item.length);
        return result;
    }

    function readBytes(bytes memory _in) internal pure returns (bytes memory) {
        return readBytes(toRlpItem(_in));
    }

    // function readBytes(RLPItem memory item) internal pure returns (bytes memory) {
    //     require(item.length > 0);

    //     (uint256 ptr, uint256 length) = payloadLocation(item);
    //     bytes memory result = new bytes(length);

    //     uint256 destPtr;
    //     assembly {
    //         destPtr := add(0x20, result)
    //     }

    //     copy(ptr, destPtr, length);
    //     return result;
    // }
    function readBytes(
        RLPItem memory _in
    ) internal pure returns (bytes memory) {
        (
            uint256 itemOffset,
            uint256 itemLength,
            RLPItemType itemType
        ) = _decodeLength(_in);

        require(itemType == RLPItemType.DATA_ITEM, "Invalid RLP bytes value.");

        return _copy(_in.ptr, itemOffset, itemLength);
    }

    function readBytes32(bytes memory _in) internal pure returns (bytes32) {
        return readBytes32(toRlpItem(_in));
    }

    function readBytes32(RLPItem memory item) internal pure returns (bytes32) {
        require(item.length <= 33);

        (uint256 ptr,) = payloadLocation(item);
        bytes32 result;
        uint256 destPtr;
        assembly {
            destPtr := add(0x20, result)
        }

        copy(ptr, destPtr, 32);
        return result;
    }

    function readBool(bytes memory _in) internal pure returns (bool) {
        return readBool(toRlpItem(_in));
    }

    // any non-zero byte except "0x80" is considered true
    function readBool(RLPItem memory item) internal pure returns (bool) {
        require(item.length == 1);
        uint256 result;
        uint256 ptr = item.ptr;
        assembly {
            result := byte(0, mload(ptr))
        }

        // SEE Github Issue #5.
        // Summary: Most commonly used RLP libraries (i.e Geth) will encode
        // "0" as "0x80" instead of as "0". We handle this edge case explicitly
        // here.
        if (result == 0 || result == STRING_SHORT_START) {
            return false;
        } else {
            return true;
        }
    }

    function readAddress(bytes memory _in) internal pure returns (address) {
        return readAddress(toRlpItem(_in));
    }

    function readAddress(RLPItem memory item) internal pure returns (address) {
        // 1 byte for the length prefix
        require(item.length == 21);

        return address(uint160(readUint256(item)));
    }

    /**
     * Reads an RLP uint256 value into a uint256.
     * @param _in RLP uint256 value.
     * @return Decoded uint256.
     */
    function readUint256(bytes memory _in) internal pure returns (uint256) {
        return readUint256(toRlpItem(_in));
    }

    function readUint256(RLPItem memory item) internal pure returns (uint256) {
        require(item.length > 0 && item.length <= 33);

        (uint256 ptr, uint256 length) = payloadLocation(item);

        uint256 result;
        assembly {
            result := mload(ptr)

            // shift to the correct location if neccesary
            if lt(length, 32) {
                result := div(result, exp(256, sub(32, length)))
            }
        }

        return result;
    }

    // enforces 32 byte length
    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {
        // one byte prefix
        require(item.length == 33);

        uint256 result;
        uint256 ptr = item.ptr + 1;
        assembly {
            result := mload(ptr)
        }

        return result;
    }


    /*
     * Private Helpers
     */

    // @return number of payload items inside an encoded list.
    function numItems(RLPItem memory item) private pure returns (uint256) {
        if (item.length == 0) return 0;

        uint256 count = 0;
        uint256 currPtr = item.ptr + _payloadOffset(item.ptr);
        uint256 endPtr = item.ptr + item.length;
        while (currPtr < endPtr) {
            currPtr = currPtr + _itemLength(currPtr); // skip over an item
            count++;
        }

        return count;
    }

    // @return entire rlp item byte length
    function _itemLength(uint256 ptr) private pure returns (uint256) {
        uint256 itemLen;
        uint256 byte0;
        assembly {
            byte0 := byte(0, mload(ptr))
        }

        if (byte0 < STRING_SHORT_START) {
            itemLen = 1;
        } else if (byte0 < STRING_LONG_START) {
            itemLen = byte0 - STRING_SHORT_START + 1;
        } else if (byte0 < LIST_SHORT_START) {
            assembly {
                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is
                ptr := add(ptr, 1) // skip over the first byte

                /* 32 byte word size */
                let dataLen := div(mload(ptr), exp(256, sub(32, byteLen))) // right shifting to get the length
                itemLen := add(dataLen, add(byteLen, 1))
            }
        } else if (byte0 < LIST_LONG_START) {
            itemLen = byte0 - LIST_SHORT_START + 1;
        } else {
            assembly {
                let byteLen := sub(byte0, 0xf7)
                ptr := add(ptr, 1)

                let dataLen := div(mload(ptr), exp(256, sub(32, byteLen))) // right shifting to the correct length
                itemLen := add(dataLen, add(byteLen, 1))
            }
        }

        return itemLen;
    }

    // @return number of bytes until the data
    function _payloadOffset(uint256 ptr) private pure returns (uint256) {
        uint256 byte0;
        assembly {
            byte0 := byte(0, mload(ptr))
        }

        if (byte0 < STRING_SHORT_START) {
            return 0;
        } else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) {
            return 1;
        } else if (byte0 < LIST_SHORT_START) {
            // being explicit
            return byte0 - (STRING_LONG_START - 1) + 1;
        } else {
            return byte0 - (LIST_LONG_START - 1) + 1;
        }
    }

    /*
     * @param src Pointer to source
     * @param dest Pointer to destination
     * @param length Amount of memory to copy from the source
     */
    function copy(uint256 src, uint256 dest, uint256 length) private pure {
        if (length == 0) return;

        // copy as many word sizes as possible
        for (; length >= WORD_SIZE; length -= WORD_SIZE) {
            assembly {
                mstore(dest, mload(src))
            }

            src += WORD_SIZE;
            dest += WORD_SIZE;
        }

        if (length > 0) {
            // left over bytes. Mask is used to remove unwanted bytes from the word
            uint256 mask = 256**(WORD_SIZE - length) - 1;
            assembly {
                let srcpart := and(mload(src), not(mask)) // zero out src
                let destpart := and(mload(dest), mask) // retrieve the bytes
                mstore(dest, or(destpart, srcpart))
            }
        }
    }

        /**
     * Decodes the length of an RLP item.
     * @param _in RLP item to decode.
     * @return Offset of the encoded data.
     * @return Length of the encoded data.
     * @return RLP item type (LIST_ITEM or DATA_ITEM).
     */
    function _decodeLength(
        RLPItem memory _in
    ) private pure returns (uint256, uint256, RLPItemType) {
        require(_in.length > 0, "RLP item cannot be null.");

        uint256 ptr = _in.ptr;
        uint256 prefix;
        assembly {
            prefix := byte(0, mload(ptr))
        }

        if (prefix <= 0x7f) {
            // Single byte.

            return (0, 1, RLPItemType.DATA_ITEM);
        } else if (prefix <= 0xb7) {
            // Short string.

            // slither-disable-next-line variable-scope
            uint256 strLen = prefix - 0x80;

            require(_in.length > strLen, "Invalid RLP short string.");

            return (1, strLen, RLPItemType.DATA_ITEM);
        } else if (prefix <= 0xbf) {
            // Long string.
            uint256 lenOfStrLen = prefix - 0xb7;

            require(
                _in.length > lenOfStrLen,
                "Invalid RLP long string length."
            );

            uint256 strLen;
            assembly {
                // Pick out the string length.
                strLen := div(
                    mload(add(ptr, 1)),
                    exp(256, sub(32, lenOfStrLen))
                )
            }

            require(
                _in.length > lenOfStrLen + strLen,
                "Invalid RLP long string."
            );

            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);
        } else if (prefix <= 0xf7) {
            // Short list.
            // slither-disable-next-line variable-scope
            uint256 listLen = prefix - 0xc0;

            require(_in.length > listLen, "Invalid RLP short list.");

            return (1, listLen, RLPItemType.LIST_ITEM);
        } else {
            // Long list.
            uint256 lenOfListLen = prefix - 0xf7;

            require(_in.length > lenOfListLen, "Invalid RLP long list length.");

            uint256 listLen;
            assembly {
                // Pick out the list length.
                listLen := div(
                    mload(add(ptr, 1)),
                    exp(256, sub(32, lenOfListLen))
                )
            }

            require(
                _in.length > lenOfListLen + listLen,
                "Invalid RLP long list."
            );

            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);
        }
    }

        function _copy(
        uint256 _src,
        uint256 _offset,
        uint256 _length
    ) internal pure returns (bytes memory) {
        bytes memory result = new bytes(_length);
        if (result.length == 0) {
            return result;
        }

        bytes memory src;
        bytes memory dst;
        assembly {
            src := add(_src, _offset)

            dst := add(result, 32)

            for {
                let i := 0
            } lt(i, _length) {
                i := add(i, 32)
            } {
                mstore(add(dst, i), mload(add(src, i)))
            }
        }

        // Pick out the remaining bytes.
        uint256 mask;
        unchecked {
            mask = 256 ** (32 - (_length % 32)) - 1;
        }

        assembly {
            mstore(dst, or(and(mload(src), not(mask)), and(mload(dst), mask)))
        }

        return result;
    }
}
